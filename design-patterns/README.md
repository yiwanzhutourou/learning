# 用 Java 实现《Design Patterns》中的例子

## 1. 抽象工厂（Abstract Factory）

#### 意图

提供一个可以构建一系列具有关联性的对象的接口，而不需要指定这些对象具体的类。

例如，一个有图形化界面的编辑器可以有不同的界面风格，在不同的界面风格下，窗口、按钮、滚动条等组件有不同的视觉风格和交互行为。为了达到可以灵活更换不同界面外观的目的，编辑器显然不应该将其实现与具体的组件耦合起来。

抽象工厂提供一系列“生产”产品的方法，具体工厂实现这些方法，“生产”具体产品。客户端应该依赖抽象工厂，而不是具体工厂，来获取每一种产品的实例，而不需要关心被“生产”的是哪一种产品。客户端只需要依赖抽象工厂创建产品，以及依赖抽象产品暴露的接口实现业务逻辑。

#### 适用场景

- 系统不关心其组件如何创建、组成和表现
- 系统可以由几种不同风格的相关组件组合而成
- 一种风格的组件不可以与另一种风格的组件搭配使用
- 提供一系列组件的类库，而又不希望暴露其实现时

#### 结构图

![抽象工厂模式结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191108180602.png)

#### 参与角色

- 抽象工厂（Abstract Factory） - 定义创建产品的接口
- 具体工厂（Concrete Factory） - 实现抽象工厂的接口
- 抽象产品（Abstract Product） - 定义某一类型的产品行为的接口，由具体工厂创建
- 具体产品（Abstract Product） - 实现抽象产品的接口
- 客户端（Clients） - 只可以依赖抽象工厂和抽象产品定义的接口

#### 好处

- 隔离了系统组件的具体实现
- 方便替换不同的实现
- 保证系统组件的一致性

#### 问题和解决方案

- 新增组件比较困难，需要修改抽象工厂接口和所有的具体工厂类（违背了“对修改关闭，对扩展开放”原则）。抽象工厂可以仅提供一个通用的“生产”接口，根据传入的变量动态“生产”，例如下面的示例代码：

  ```java
  // 根据产品类型生产，坏处是返回的永远是 Product 对象
  Product make(ProductType productType, ...其他参数);
  
  // 根据类型动态生产
  T make(Class<T> productType, ...其他参数);
  ```

  **个人理解：具体的 make 实现还可以代理出去，由每一种产品的生产代理类提供生产实现，这样新增产品时就不会涉及到抽象工厂和具体工厂的修改了。当然，具体取舍还要看业务场景。**