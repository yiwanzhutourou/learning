# 享元模式（Flyweight）

## 词汇表

- instrinsic - 固有的，内在的
- extrinsic - 非固有的，外在的

## 意图

> Use sharing to support large numbers of fine-grained objects efficiently.
>
> 使用共享对象来有效地支持大量的小对象。

一个文本编辑器应用可能不仅将图表、段落以及行这些元素设计为一个对象，而且将每一个字符也设计为一个对象，这样可以使整个框架更灵活、更易于扩展，例如在渲染文本的时候，行对象只需要关心行这个级别上的绘制逻辑，而对于字符的绘制，直接调用 `Character.draw()` 方法即可，这样的话，对于不同字体的字符的绘制的逻辑就是在最细的粒度上复用的，新增字体并不需要修改行以及更大粒度的元素的绘制逻辑。但是，将一个文本中的所有字符都实例化为一个对象显然是不现实的，创建大量小对象的内存开销是巨大的，这时候就可以考虑应用享元模式了。

一个享元（英文是 flyweight，蝇量级，拳击比赛的一个级别，这里意译为享元，也有翻译为蝇量的）对象是一个可以在不同上下文中被使用的共享对象。对象的属性分固有属性和非固有属性，共享对象仅具有固有属性，而非固有属性存在于使用对象时的上下文中。例如，在文本编辑器的例子里，每一个字符对象可以共享一个享元对象，这个享元对象没有固有属性，而在绘制字符时，需要将字符编码、字体、大小、颜色等这些非固有属性作为上下文传递给享元对象。使用享元模式后，应用中对象的数量急剧减小。

在 Java 中，很多基础数据类型的包装类都采用了享元模式，例如 `Integer` 类就默认缓存了 -128 到 127 的值：

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

一般享元对象的固有属性应该是不可变的（immutable）。

## 适用场景

只有在下面的条件都满足的情况下才适合使用享元模式：

- 应用需要大量的对象，且因此需要大量的内存。
- 对象的大部分属性都是非固有的，且一旦这些属性被移除后，这些对象就可以被少量的共享对象替代了。
- 应用的逻辑不依赖对象的相等性比较，因为大量对象共享自一个对象，它们实际上是同一个对象，但是逻辑上并不相等。

## 结构图

![享元模式结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191130170431.png)

使用享元模式时的对象关系如下：

![享元模式对象关系图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191130170530.png)

## 参与角色

- Flyweight
  - 定义一个使用外部传入的属性实现逻辑的接口
- ConcreteFlyweight
  - 实现 Flyweight 定义的接口
  - 保存独立于上下文的固有属性
- UnsharedConcreteFlyweight
  - 不是所有的 Flyweight 子类都必须是共享的。非共享的对象可以包含共享对象。
- FlyweightFactory
  - 创建并管理享元对象
- Client
  - 使用享元对象
  - 计算或者存储享元对象需要的上下文

## 好处

享元模式实际上是在时间和空间上做取舍的结果，节省了空间，意味着需要额外的时间开销用于查找享元对象、计算上下文等。