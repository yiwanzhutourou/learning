# 抽象工厂（Abstract Factory）

## 意图

> Provide an interface for creating families of related of dependent objects without specifying their concrete classes.
>
> 提供一个可以构建一系列具有关联性的对象的接口，而不需要指定这些对象具体的类。

例如，一个有图形化界面的编辑器可以有不同的界面风格，在不同的界面风格下，窗口、按钮、滚动条等组件有不同的视觉风格和交互行为。为了达到可以灵活更换不同界面外观的目的，编辑器显然不应该将其实现与具体的组件耦合起来。

抽象工厂提供一系列“生产”产品的方法，具体工厂实现这些方法，“生产”具体产品。客户端应该依赖抽象工厂，而不是具体工厂，来获取每一种产品的实例，而不需要关心被“生产”的是哪一种产品。客户端只需要依赖抽象工厂创建产品，以及依赖抽象产品暴露的接口实现业务逻辑。

## 适用场景

- 系统不关心其组件如何创建、组成和表现。
- 系统可以由几种不同风格的相关组件组合而成。
- 一种风格的组件不可以与另一种风格的组件搭配使用。
- 提供一系列组件的类库，而又不希望暴露其实现时。

## 结构图

![抽象工厂模式结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191108180602.png)

## 参与角色

- 抽象工厂（Abstract Factory）
  - 定义创建产品的接口
- 具体工厂（Concrete Factory）
  - 实现抽象工厂的接口
- 抽象产品（Abstract Product）
  - 定义某一类型的产品行为的接口，由具体工厂创建
- 具体产品（Abstract Product）
  - 实现抽象产品的接口
- 客户端（Clients）
  - 只可以依赖抽象工厂和抽象产品定义的接口

## 好处

- 隔离了系统组件的具体实现。
- 方便替换不同的实现。
- 保证系统组件的一致性。

## 问题和解决方案

新增组件比较困难，需要修改抽象工厂接口和所有的具体工厂类（违背了“对修改关闭，对扩展开放”原则）。抽象工厂可以仅提供一个通用的“生产”接口，根据传入的变量动态“生产”，例如下面的示例代码：

```java
// 根据产品类型生产，坏处是返回的永远是 Product 对象
Product make(ProductType productType, ...其他参数);

// 根据类型动态生产
T make(Class<T> productType, ...其他参数);
```

当然，这样做似乎也有坏处，如果每一种产品的构造参数不同，通用的 make 函数似乎会增加调用方的理解和使用成本。另外，make 函数如何实现也是一个问题，似乎可以维护一个产品类型到构造方法的 map，那么新增产品时只需要微调这个 map 的初始化即可。