# 观察者模式（Observer）

## 意图

> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
>
> 定义一个对象之间的一对多关系，当一个对象的状态改变时，所有依赖于它的对象都可以接到通知并自动更新。

当你为了保持系统中相关对象的状态一致，而又不想这些对象紧耦合时，可以使用观察者模式。例如，系统中多个图形化组件显示同一组数据，比如饼状图、表格等，数据变化时，这些组件要相应变化。直接调用这些组件提供的更新接口这样紧耦合的方式肯定是不合适的，这样每增加一个新的组件可能都要修改调用处的代码。使用观察者模式，让这些图形化组件都订阅数据变化的消息，在数据变化时通知它们即可。每一个图形化组件都是一个抽象的观察者（Observer），数据，或者称为主题（Subject）在自身变化时通知所有注册了的观察者，主题无需知道观察者是谁，只知道它们实现了 Observer 接口。后续如果有新的组件也要关心数据的变化，只需要实现 Observer 接口，并调用主题的注册接口将自己在合适的时机注册到观察者列表就可以监听数据的变化了，主题的代码完全不需要变动。

## 适用场景

- 当需要将互相依赖的两个逻辑分开以方便扩展和复用时。

- 一个对象改变，另外一些对象也需要改变，并且你不能确定这样的对象有多少时。
- 当一个对象需要通知另外一些对象，而完全不需要知道它们是谁时，也就是你想要对象之间松耦合时。

## 结构图

![观察者模式结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191201024319.png)

## 参与角色

- Subject - 主题
  - 任意数量的观察者都可以观察主题
  - 提供绑定和解绑观察者的接口
- Observer - 观察者
  - 定义一个 `update` 接口
- ConcreteSubject - 具体主题
  - 保存 Observer 关心的状态
  - 当状态发生变化时通知所有观察者

- ConcreteObserver - 具体观察者
  - 维护一个主题的引用
  - 维护一组状态，且和具体主题保持步调一致
  - 实现 `update` 接口

## 好处

观察者模式使得主题和观察者松耦合，方便对主题和观察者分别做扩展，且新增观察者不需要修改主题和其他观察者的代码。主题完全不需要知道观察者具体是什么类，而仅需要知道它们实现了 Observer 接口，主题和观察者完全可以是不同的模块或者不同的层级里的类。

## 缺点

- 由于不清楚具体有哪些观察者存在，轻易改变主题可能会造成一些耗时操作发生。

- 观察者执行顺序的不同可能会造成隐藏的问题，且不容易定位。

## 实现

- 实现观察者模式有推和拉两种模式，推的模式是主题在通知观察者时将相应数据作为 `update` 方法的参数传递给观察者，这种模式需要主题知道观察者的一些细节。拉的模式是主题完全不关心观察者需要的数据，由观察者调用主题的接口获取数据，这种模式下需要观察者自己判断主题的哪些状态变化了。
- 可以在注册接口上增加参数，使观察者可以只观察自己关心的状态的变化，当主题的某些状态变化时只通知关心这些状态变化的观察者。
- 当遇到多个主题的变化都有可能引起多个观察者的变化这样的复杂情况时，可以考虑实现一个 ChangeManager 专门管理绑定、解绑和通知的逻辑，有的时候多个主题的变化可以合并为一个通知给到观察者。