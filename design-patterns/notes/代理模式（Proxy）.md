# 代理模式（Proxy）

## 意图

> Provide a surrogate or placeholder for another object to control access to it.
>
> 提供一个代理或者站位对象来使用另一个对象。

## 适用场景

代理模式适用于任何不仅仅需要一个简单的“指针”的场景，例如：

- 远程代理（remote proxy）代理一个不在本地地址空间的对象。
- 虚拟代理（virtual proxy）代理一个初始化代价昂贵的对象，可以将被代理对象的初始化尽量延迟（create on demand）。
- 保护代理（protection proxy）控制对代理对象的访问权限，在代理层增加权限控制的逻辑。
- 智能引用（smart reference）通常可以用于引用计数（一些垃圾清理算法基于引用计数）、懒加载持久化对象或者增加锁逻辑等。

## 结构图

![代理模式结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191127181001.png)

运行时的对象关系如下：

![代理模式运行时对象关系图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191127181129.png)

## 参与角色

- Proxy
  - 持有被代理对象的引用
  - 提供一个和被代理对象一致的接口
  - 控制对被代理对象的使用，也可能负责被代理对象的创建和销毁
  - 代理对象的其他可能的职责：
    - 远程代理（remote proxy）需要根据通信协议对数据做编解码
    - 虚拟代理（virtual proxy）可能需要维护被代理对象的一些信息，某些设置类的操作代理对象可以代劳，尽量延迟创建被代理对象
    - 保护代理（protection proxy）需要检查调用方是否具有相应的权限
- Subject
  - 定义代理对象和被代理对象的统一接口，使得可以直接使用被代理对象的地方也可以使用代理对象
- RealSubject
  - 被代理对象

## 好处

- 远程代理（remote proxy）可以隐藏远程调用的细节，使得一个远程调用看起来就像是一个本地调用，例如各种 RPC 框架的实现。
- 虚拟代理（virtual proxy）可以提供懒加载的优化，使一些开销比较大的对象的创建尽量延后。
- 保护代理（protection proxy）和智能引用（smart reference）可以起到管家的角色，在调用被代理对象的方法时起到各种控制作用。
- 可以使用代理模式实现 Copy On Write，在拷贝一个大对象时先返回这个大对象的代理对象，而不是真的拷贝这个对象，只有在调用方调用到代理对象的写方法时，才真的拷贝一份出来。

## 与其他模式的对比

- 适配器模式是将原对象的接口“适配”为新的接口，因此原则上适配器的接口与原对象不同，而代理模式中代理的接口与原对象是相同的。
- 装饰器模式和代理模式的实现方式非常相似，但是它们要达到的目的不同。装饰器是对原对象能力的增强，需要考虑原对象的所有接口，而代理对象用于控制对原对象的使用，代理对象可能只代理原对象的部分接口。另外，代理模式中，被代理对象可能并不实际存在，例如远程代理（remote proxy）中，被代理对象其实并不在本地地址空间中，而可能只是服务器的地址和端口。

## 思考

1. Spring 中的动态代理的原理是什么？