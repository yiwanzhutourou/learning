# 适配器模式（Adapter）

## 意图

> Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
>
> 将接口转换为客户端预期的接口。适配器可以使本不可以配合使用的不兼容接口配合使用。

这里以日志框架来说明适配器模式的应用场景。我们可能听过很多日志框架，例如 slf4j、commons-logging、logback、log4j 等，它们之间到底是什么关系呢？其实用设计模式的语言来描述的话，slf4j 和 commons-logging 是各种日志实现的门面（Facade），这两个库中并没有日志功能的具体实现，只是提供了一种 API 规范，而 logback 和 log4j 等才是具体的日志实现库。slf4j 规范是比较晚才提出来的，log4j 在 slf4j 提出之前就已经实现了，因此并没有实现 log4j 的接口，那么一些已经使用了 log4j 的老项目如何切换到使用新的 slf4j 规范呢？这就需要一个额外的适配器来解决接口兼容的问题。因此，老项目要想不修改代码就切换到使用新的 slf4j 规范，应该去掉 log4j 实现库，再引入三个库，一个将 log4j 接口适配为 slf4j 接口的适配器，slf4j API 库，以及一个 slf4j 的实现库，如下图所示：

![log4j to slf4j](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191204173238.png)

上图中，适配器库的名字显示为 slf4j bridge，其实我理解这里这个库应该被理解为一个适配器（adapter）。桥接模式（Bridge）和适配器模式非常相似，它们的区别主要在意图上。桥接模式是一种提前设计，目的是为了使相互依赖的两个模块通过一个中间层而解耦，使得它们可以独立于彼此而演进，其中一方改变，只要相应修改中间层就不会影响到对方。而适配器模式更多强调的是对已经存在的老接口的适配，使得老接口可以切换到使用新的实现。

## 适用场景

- 当你需要使用一个已经存在的类，但是这个类的接口与你需要的接口不匹配的时候。
- 当你需要提供一个可复用的类与不相关的或者不可预见的类交互的时候。

## 结构图

适配器分为对象适配器（object adapter）和类适配器（class adapter），对象适配器基于对象的组合，其结构图如下所示：

![对象适配器结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191204163858.png)

类适配器基于多继承（multiple inheritance），其结构图如下所示：

![类适配器结构图](https://youdu-markdown.oss-cn-shanghai.aliyuncs.com/20191204163858.png)

Java 不支持多继承，因此 Java 中的适配器多是对象适配器。对象适配器和类适配器的区别可以参考组合与继承的区别。

## 参与角色

- Target
  - 定义 Client 可以使用的接口
- Client
  - 与 Target 交互

- Adaptee
  - 定义一个已经存在的需要适配的接口
- Adapter
  - 适配 Adaptee 的接口实现 Target 的接口

## 结果

类适配器

- 因为使用了继承，因此只能适配某一个类，而不能适配所有的子类。
- 因为使用了继承，因此可以覆盖被适配类的某些行为。
- 相对于对象适配器，只需要一个对象，不需要额外的包装类。
- 因为既继承了 Target 又继承了 Adaptee，因此实现了一种双向适配器，既可以用在老系统中，又可以用在新系统中。

对象适配器

- 因为使用了组合，一个适配器可以适配多个类。
- 相对于类适配器，想要覆盖被适配对象的行为相对比较困难。

## 与其他模式的比较

- 与桥接模式（Bridge）的对比可以参考「意图」一节。
- 适配器模式、装饰器模式（Decorator）和代理模式（Proxy）的表现形式非常相似，都是用一个对象包装另一个对象，但是它们的意图不同。适配器模式是要兼容不兼容的接口，因此适配器对象和被包装对象的接口不同。装饰器模式意在对一个对象的能力的增强，装饰器和被包装对象拥有相同的接口，且拥有相同的父类。代理模式强调的是作为被包装对象的代理，在代理中可以控制访问权限，或者代理对象甚至可以不在同一个进程中，代理模式一般具有和被代理对象一样的接口，但是并不一定代理被代理对象的所有接口，也并不需要拥有相同的父类。在实际应用场景中，应该主要考虑我们要解决什么问题，并不强求一定生搬硬套这几种模式。