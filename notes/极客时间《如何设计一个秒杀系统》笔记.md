## 极客时间《如何设计一个秒杀系统》笔记

注：以下凡 *斜体* 的内容都是我自己的思考，凡包括在引用内的内容都是原文摘抄，其他内容为内容总结。

*《如何设计一个秒杀系统》的内容主要是阿里的前技术专家针对“秒杀”这个场景，讲解如何设计一个高并发、高可用的系统。我觉得整个专栏的主要价值在于提供了一些设计的原则和思路，至于具体如何落地，还需要根据生产中，业务的体量和实际情况再做实践。专栏的另外一个价值也在于透露了一些阿里这样的大厂关于如何做高并发、高可用系统的思路。*

#### 开篇

> 简单来说，秒杀就是在同一个时刻有大量的请求争抢购买同一个商品并完成交易的过程，用技术的行话来说就是大量的并发读和并发写。

> **秒杀其实主要解决两个问题，一个是并发读，一个是并发写。**并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。

*这里提到了几个核心思路。一是利用缓存减少服务器压力，静态数据走 CDN 缓存减少用户直接请求服务器的数量，动态数据走 redis 缓存减少数据库读压力。二是数据库分库，热点数据分散到不同的库里可以避免大量并发写请求落到一个数据库上。三是一定要设计兜底方案，避免最坏的情况——例如，服务器直接宕机——的发生。*

从架构角度，我们的系统应该满足以下几个方面的要求：

- 高性能。可以支持大量的并发读写。可以从**动静分离、热点数据的发现和隔离、削峰填谷、服务端性能优化**等方面考虑。
- 一致性。在大量并发写的情况下仍要保证数据的一致性，例如秒杀扣库存不能多扣。
- 高可用。一定要设计 Plan B 兜底方案，即使出现最坏的情况，也有应对方案。

#### 5 个架构原则（4 要 1 不要）

1. 数据要尽量少

其一，减少请求服务器的数据和服务器返回的数据，可以减少服务器对数据压缩、编解码的时间，而这些操作都非常消耗 CPU。

其二，减少系统依赖的数据，包括系统完成某些业务逻辑需要读取和保存的数据。这些数据要么来自于依赖的后台服务，要么来自于数据库。调用其他服务涉及数据的序列化反序列化，而数据库往往容易成为瓶颈。

*这里我的理解是，专栏讲解的是“秒杀”这样的场景下的极致优化，这里提到的“减数据”除了从代码层面做到尽量精简外，还需要从业务角度来做精简。因此，在设计系统时可以考虑与业务沟通，做到性能和易用性的平衡。如果是“秒杀”这样的场景，或者是可以预计到的大流量场景，可以考虑只提供核心功能，例如秒杀页面上尽量减少相关产品的展示。*

2. 请求数量尽量少

页面依赖的 CSS / Javascript、图片以及 Ajax 等额外请求应该尽量少。例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开。文件在服务端仍单独存放，只是服务端会有一个组件解析这个 URL，然后动态把这些文件合并起来一起返回。

3. 路劲要尽量短

缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。要缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成 JVM 内部之间的方法调用。（《大型网站技术架构演进与性能优化》里有一章介绍了这种技术的详细实现。）

4. 依赖要尽量少

> 要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。

> 注意，0 级系统要尽量减少对 1 级系统的强依赖，防止重要的系统被不重要的系统拖垮。例如支付系统是 0 级系统，而优惠券是 1 级系统的话，在极端情况下可以把优惠券给降级，防止支付系统被优惠券这个 1 级系统给拖垮。

5. 不要有单点

> 系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。

> **架构是一种平衡的艺术，而最好的架构一旦脱离了它所适应的场景，一切都将是空谈。我希望你记住的是，这里所说的几点都只是一个个方向，你应该尽量往这些方向上去努力，但也要考虑平衡其他因素。**

*我的理解是，任何架构上的设计都应该根据实际情况来，是对性能和通用性的平衡。优化往往不是发生在系统的第一个版本，而是发生在出现实际需要的时候。例如，我们可能先设计出一个通用的交易平台，能够满足目前的以及可预见的业务体量即可，等到公司需要出现一个“秒杀”的业务场景时，再做针对性优化。又例如，专栏中有提到秒杀商品数据库可以是一个独立于普通商品的数据库，避免少量热点数据影响其他正常数据的读写。我们在最初设计商品中心的时候往往是先把精力放在如何设计一个通用的、易于扩展的商品服务，而不会在一开始就考虑这样一个库的存在。当然，如何在系统设计之初就遇见到这些情况，留有扩展的余地，也是需要考量的。*

#### 动静分离

“静态数据”不单单指前后端分离后的 HTML、CSS、JavaScript 等静态文件，也包括 Java 动态生成的，但是与“浏览者、时间、地域等”无关的数据，例如媒体网站的文章就是静态数据，推荐商品就是动态数据。

*我理解其实静态数据大部分就是指静态的 HTML、CSS、JavaScript 文件了，前后端分离已经是目前的大方向了，这些静态文件可以做 CDN 缓存从而减少用户直接访问服务器的数量。至于 Java 动态生成的所谓“静态数据”我们往往也很容易区分，这些数据往往也不能做 CDN 缓存，而是利用 redis 或者甚至服务器本地内存等缓存来减少对数据库的压力。*

#### 热点数据问题

1. 如何发现热点数据？可以**考虑**以下几种“思路”：

- 从业务角度发现。例如，参加秒杀活动必须先报名，利用这种方式提前发现热点数据，再利用后台运营工具，在活动开始前将这些数据提前写进缓存。
- 从大数据角度提前发现。例如，对平台每天的被访问、加入购物车、购买的商品做统计，计算出 TOP N 的商品，可以认为这些 TOP N 的商品就是热点数据。
- **动态发现热点数据。**利用请求从上游系统到下游系统之间的时间差，在整个系统链路上构建一个异步的收集、上报热点数据的机制。例如在 Nginx、缓存、上游系统中发现热点数据的 Key 值，利用消息队列等发布热点数据的广播，下游系统可以订阅这些消息，提前识别出热点数据，将其加入缓存。主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。

> 热点发现要做到接近实时（3s 内完成热点数据的发现），因为只有做到接近实时，动态发现才有意义，才能实时地对下游系统提供保护。

2. 如何处理热点数据？可以**考虑**以下几种“思路”：

- 缓存。根据需要，缓存到 redis 集群，或者本地内存。需要考虑好缓存失效的策略、缓存的数据量大小、如何应对缓存穿透等问题。
- 限制。例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。
- 隔离。例如，启用单独的数据库、单独的 Cache 集群存放热点数据。

#### 流量削峰

1. 利用消息队列来缓冲瞬时流量，保证下游系统始终可以匀速处理请求，不至于被上游系统瞬间的大流量拖垮。

*如果“秒杀”系统直接采用这种方法，在收到用户请求后立即返回，将请求直接加入消息队列慢慢处理，似乎可以增加整个服务器的吞吐量，但是因为必须“异步”告知用户结果，似乎在业务上并不能被接受。另外，在“秒杀”这样的场景下，只有小部分用户最终可以抢到商品，因此把很多无效请求加入到队列也是没必要的。*

2. 利用业务手段削峰。例如答题，利用答题其一可以防止秒杀器作弊，其二可以延缓请求，将 1s 内的流量高峰分散到 2s - 10s。

#### 服务端性能优化

1. 服务端性能指标：

- QPS（Queries Per Second），每秒可以处理的请求数。
- 响应时间（Response Time），服务器处理每一个请求的时间，由 CPU 执行时间和等待时间（IO、锁）两部分组成。

2. 减少等待时间对 QPS 的提升不是线性的，因为我们可以通过调整线程的数量来提升 QPS，例如，根据线程数的经验公式，线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量，对于等待时间长的任务，增加线程数可以增加 CPU 利用率，继而提高 QPS。
3. 